/**
 * @file SysSygnalsController.h
 *
 * @brief Файл заголовка описания класса SysSignalsController реализации данных
 * и методов для работы с сигналами ОC *NIX
 *
 * @author Владимир Н. Литвиненко.
 * @orhanization Санкт-Петербургский филиал ПАО "НПО "Стрела"
 * @copyright Все права защищены.
 */

#ifndef SYSSIGNALSCONTROLLER_H
#define SYSSIGNALSCONTROLLER_H

#include "Types.h"

#include <csignal>

#include <unordered_map>
#include <functional>
#include <vector>

#include <boost/bind/bind.hpp>

namespace                         htl   {
namespace                         sys   {

//------------------------------------------------------------------------------
/**
 * @typedef signals_t
 * @brief Контейнер типа @a std::vector нвбора сигналов ОС *NIX
 */
using signals_t                 = std::vector< std::sig_atomic_t >;

/**
 * @brief Константа UNIX_SIGNALS содержит список сигналов ОС *NIX
 */
const signals_t                   UNIX_SIGNALS
{
/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGHUP — сигнал, посылаемый процессу для уведомления о
 * потере соединения с управляющим терминалом пользователя.
 *
 * SIGHUP — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * POSIX закрепляет за SIGHUP значение 1.
 * Например, для активации новых терминалов после их добавления в файл
 * /etc/ttys рекомендуется послать SIGHUP процессу init,
 * командой «kill -1 1» (init имеет PID = 1).
 *
 * Сигнал SIGHUP посылается:
 *
 *  При прерывании соединения на последовательной линии, программам, запущенным
 *  с терминала подключенного к ней, часто из-за того, что пользователь
 *  отсоединяет свой модем от телефонной или выделенной линии.
 *  Операционная система определяет разрыв соединения по исчезновению сигнала
 *  «несущая» (англ.  carrier detect, DCD) последовательного порта.
 *
 *  При закрытии псевдо- или виртуальных терминалов, которые используются на
 *  современных системах вместо аппаратных терминалов.
 *
 *  Утилитой или функцией kill, с консоли или из скрипта/утилиты для управления
 *  демоном, для выполнения предусмотренного действия (обычно — перечитывания
 *  конфигурации и переинициализации).
 *
 * Обычным действием по умолчанию для SIGHUP в POSIX-системах является
 * завершение процесса.
 *
 * Unix-шелл, при получении SIGHUP, обычно запускает заново все остановленные
 * задачи, перед посылкой им SIGHUP. В других реализациях (например, GNU bash),
 * шелл «отрекается» от всех дочерних задач перед завершением (и они продолжают
 * работать).
 *
 * SIGHUP может быть перехвачен или проигнорирован программой.
 *
 * Для предотвращения завершения SIGHUP стандартных программ и утилит,
 * существует утилита nohup («префикс» для программы в командной строке).
 * nohup настраивает игнорирование SIGHUP, после чего запускает программу с
 * аргументами в фоновом режиме с перенаправлением вывода в файл nohup.out в
 * текущем или домашнем каталоге пользователя.
 *
 * Сигнал SIGHUP посылается приложению так же и в том случае, если процесс-лидер
 * сессии завершил свою работу. Многие программы-демоны, у которых нет лидера
 * сессии, так же обрабатывают этот сигнал. В ответ на получение SIGHUP демон
 * обычно перезапускается (или просто повторно читает файл конфигурации).
 * По умолчанию программа, получившая этот сигнал, завершается.
 */
                                  SIGHUP,   /* Hangup (POSIX).  */
/* -----------------------------------------------------------------------------
 * Сигнал SIGINT (номер 2) обычно посылается процессу, если пользователь
 * терминала дал команду прервать процесс
 * (обычно эта команда – сочетание клавиш Ctrl-C) .
 *
 * В POSIX-системах, SIGABRT — сигнал, посылаемый процессом самому себе при
 * выполнении функции abort(), для аварийного останова, в случае невозможности
 * дальнейшего продолжения программы.
 *
 * SIGABRT — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * В GNU/Linux, также есть сигнал SIGIOT который является синонимом SIGABRT.
 *
 * Сигнал SIGABRT процесс посылает сам себе, когда вызывает функцию abort()
 * (функция libc, с прототипом в stdlib.h).
 *
 * Сигнал SIGABRT может быть перехвачен или проигнорирован, но abort()
 * принудительно завершит программу (предварительно сбросив и закрыв стандартные
 * потоки и сделав дамп памяти программы) даже если этого не сделает обработчик
 * сигнала. Таким образом функция abort() гарантирует завершение программы,
 * почему она часто используется библиотеками в аварийных ситуациях — когда
 * выполнение не должно быть продолжено, но основная программа должна иметь
 * возможность выполнить действия, необходимые перед аварийным завершением.
 *
 * Также SIGABRT вызвается утверждениями (англ. assertions; средство отладки
 * Си — макроопределение assert() вызывает abort() если утверждение переданное
 * в качестве аргумента ложно).
 */
                                  SIGINT,   /* Interrupt (ANSI).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGQUIT — сигнал, для остановки процесса пользователем,
 * комбинацией «quit» на терминале. Этот сигнал также указывает, что система
 * должна выполнить дамп памяти для процесса.
 *
 * SIGQUIT — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGQUIT посылается программе, с помощью нажатия комбинации клавиш «quit» на
 * терминале (обычно — Ctrl-\). В Linux, также Ctrl-4, или SysRq на
 * виртуальном терминале.
*/
                                  SIGQUIT,  /* Quit (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGILL — сигнал, посылаемый процессу при попытке выполнить
 * неправильно сформированную, несуществующую или привилегированную инструкцию.
 *
 * SIGILL — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * Существует много причин для SIGILL.
 * Одна из наиболее частых причин — передача управления в случайное место
 * памяти — в результате передачи управления через неинициализированный или
 * поврежденный указатель (или адрес возврата в стеке).
 * Другие случаи возможны при ошибках компилятора, повреждении файловой системы
 * или попытке выполнения инструкции, требующей специальных привилегий.
 *
 * На многих платформах, по мере развития оборудования внедряются новые
 * инструкции, регистры и т. п. и приложения, собранные для современного
 * оборудования могут содержать инструкции, не распознающиеся на более старом
 * оборудовании.
 * Например, SIGILL возникнет при попытке выполнить инструкции MMX на
 * процессоре i486, который их не поддерживает.
 *
 * SIGILL может быть перехвачен или проигнорирован. Однако игнорирование SIGILL,
 * в некоторых случаях, может привести к непредсказуемым результатам.
*/
                                  SIGILL,   /* Illegal instruction (ANSI).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGTRAP — сигнал, посылаемый для информирования отладчика
 * о возникновении интересующего события.
 *
 * SIGTRAP — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * При отладке программы, часто бывает полезной приостановка выполнения программы
 * и анализ при наступлении некоторых условий - достижения определённой точки
 * кода (например, вызова какой-нибудь функции), или изменении значения
 * определённой переменной, а также, покомандная трассировка кода программы.
 * Для этого программа-отладчик может использовать аппаратные отладочные
 * возможности компьютера.
 *
 * Сигнал аппаратного отладчика преобразуется ядром в сигнал SIGTRAP.
 *
 * При отсутствии возможности аппаратной отладки, отладчик периодически
 * останавливает программу для проверки ожидаемых условий (что гораздо менее
 * эффективно).
*/
                                  SIGTRAP,  /* Trace trap (POSIX).  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGABRT (номер 6) посылается программе в результате вызова функции
 * abort(3).
 * В результате программа завершается с сохранением на диске образа памяти.
 *
 * В POSIX-системах, SIGABRT — сигнал, посылаемый процессом самому себе при
 * выполнении функции abort(), для аварийного останова, в случае невозможности
 * дальнейшего продолжения программы.
 *
 * SIGABRT — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * В GNU/Linux, также есть сигнал SIGIOT который является синонимом SIGABRT.
 *
 * Использование:
 * Сигнал SIGABRT процесс посылает сам себе, когда вызывает функцию abort()
 * (функция libc, с прототипом в stdlib.h).
 * Сигнал SIGABRT может быть перехвачен или проигнорирован, но abort()
 * принудительно завершит программу (предварительно сбросив и закрыв стандартные
 * потоки и сделав дамп памяти программы) даже если этого не сделает обработчик
 * сигнала.
 * Таким образом функция abort() гарантирует завершение программы, почему она
 * часто используется библиотеками в аварийных ситуациях — когда выполнение не
 * должно быть продолжено, но основная программа должна иметь возможность
 * выполнить действия, необходимые перед аварийным завершением.
 *
 * Также SIGABRT вызвается утверждениями (англ. assertions; средство отладки
 * Си — макроопределение assert() вызывает abort() если утверждение переданное
 * в качестве аргумента ложно).
 */
                                  SIGABRT,  /* Abort (ANSI).  */
//                                  SIGIOT,   /* IOT trap (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGBUS — сигнал, сигнализирующий об ошибке шины, при
 * обращении к физической памяти.
 *
 * SIGBUS — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование
 * Процесс может получить SIGBUS при неправильном обращении к памяти:
 *  Неправильное выравнивание данных
 *    При попытке обращения не удовлетворяющей правилам выравнивания принятым
 *    на применяемом процессоре.
 *  Обращение к несуществующей физической памяти
 *    Обращение к адресам, для которых на компьютере не установлено памяти.
 *    Исключение аналогично ошибке сегментации, но в применении к физическим,
 *    а не виртуальным адресам.
 *  Аппаратная ошибка специфичная объекту
 *    Более редкий случай, например в Solaris такой сигнал возникает, когда
 *    страницы виртуальной памяти перестают быть доступны, из-за проблем доступа
 *    к объекту, который на них отображён (например, когда отображённый с
 *    помощью mmap() файл был впоследствии урезан [1] (англ.)).
 *
 * Операционная система может предоставить дополнительные данные о возникшей
 * ошибке, используя стек сигнала (англ. signal stack), который может помочь
 * разработчику в отладке данной ошибки.
 *
 * По умолчанию, процесс аварийно завершается с генерацией дампа памяти (и/или
 * другой операции зависящей от платформы), который можно использовать для
 * получения информации об условиях возникновения исключения.
 *
 * SIGBUS может быть перехвачен или проигнорирован.
 * Однако игнорирование SIGBUS, в некоторых случаях, может привести к
 * непредсказуемым результатам. Примером программы, перехватывающей SIGBUS,
 * может служить отладчик, который способен проанализировать стек и
 * информировать разработчика на каком этапе произошла ошибка.
*/
                                  SIGBUS,   /* BUS error (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGFPE — сигнал, посылаемый процессу, при попытке
 * выполнения ошибочной арифметической операции.
 *
 * SIGFPE — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 *  SIGFPE может быть послан процессу по ряду причин.
 *  Самая распространенная из них — переполнение типа данных в результате
 *  неожиданно больших (или малых) значений входных данных и/или ошибки дизайна
 *  программы.
 *
 * SIGFPE может быть перехвачен или проигнорирован. Игнорирование SIGFPE в
 * некоторых случаях может привести к непредсказуемым результатам — программа
 * может зациклиться в попытке выполнить ошибочную операцию.
 * Если SIGFPE не является результатом арифметической операции (а, например,
 * послан с помощью системного вызова kill()), то такое игнорирование вполне
 * безопасно.
 *
 * При делении SIGFPE вызывает не только равный нулю делитель — на некоторых
 * платформах (включая x86), целое деление INT_MIN, самого малого
 * (отрицательного) целого числа, на (−1) не может быть выполнено, поскольку
 * положительное число с этим модулем непредставимо (при INT_MIN = (−2147483648),
 * INT_MAX = 2147483647).
*/
                                  SIGFPE,   /* Floating-point exception (ANSI).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGKILL — сигнал, посылаемый процессам для их немедленного
 * завершения.
 *
 * SIGKILL — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * На большинстве платформ SIGKILL имеет значение 9, что породило выражение
 * «килл-минус-девять» (англ. kill-dash-nine), озвучивание команды типа
 * «kill -9 1234» (сокращенный синтаксис, рекомендуемый
 * вариант — «kill -s KILL 1234»)
 *
 * Использование:
 * Будучи посланным процессу, SIGKILL вызывает его немедленное завершение.
 * В отличие от SIGTERM или SIGINT этот сигнал не может быть перехвачен или
 * проигнорирован, а процесс, получивший его не имеет возможности выполнить
 * какие-либо действия перед своим завершением.
 *
 * процесс-зомби нельзя завершить SIGKILL, потому что зомби уже завершен и не
 * может принимать сигналов.
 * Зомби ожидает, что родительский процесс считает код завершения с помощью
 * системного вызова wait().
 * Процессы в состоянии блокировки (например, при ожидании ввода/вывода) не
 * смогут завершиться SIGKILL, пока операционная система не вернет их в
 * нормальное состояние (при наступлении ожидаемого события или ошибке).
 *
 * Процесс init является особым случаем — он не получает от операционной системы
 * сигналов, которые он не хочет обрабатывать, и, следовательно, может
 * игнорировать SIGKILL.
*/
                                  SIGKILL,  /* Kill, unblockable (POSIX).  */

/* -----------------------------------------------------------------------------
 * В SIGUSR1 и SIGUSR2 — пользовательские сигналы, которые могут быть использованы
 * для межпроцессной синхронизации и управления.
 *
 * SIGUSR1 и SIGUSR2 — целочисленные константы, определенные в заголовочном
 * файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGUSR1 и SIGUSR2 могут быть использованны программой для произвольных нужд,
 * например для межпроцессной (или межпоточной) синхронизации, управления
 * фоновыми процессами (демонами) и т. п. По умолчанию, сигналы SIGUSR1 и SIGUSR2
 * завершают выполнение процесса.
 *
 * Ранние разработки системы сигналов не имели пользовательских сигналов,
 * поэтому для управления демонами (для их реинициализации) традиционно
 * используется сигнал Сигналы SIGALRM | SIGHUP | SIGINT | SIGPIPE | SIGSEGV |
 * SIGUSR1 | SIGUSR2 | SIGCONT | SIGTSTP | SIGTTOU | SIGPOLL | SIGSYS | SIGURG |
 * SIGXCPU | Сигналы реального времени (определяемые пользователем) —
 * SIGRTMIN — SIGRTMAX.
 *
 * Некоторые сигналы не включенные в POSIX и синонимы SIGEMT | SIGIO |
 * SIGPWR (SIGINFO) | SIGWINCH | SIGUNUSED
*/
                                  SIGUSR1,  /* User-defined signal 1 (POSIX).  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGSEGV (номер 11) посылается процессу, который пытается обратиться
 * к не принадлежащей ему области памяти.
 * Если обработчик сигнала не установлен, программа завершается с сохранением
 * на диске образа памяти.
 *
 * В POSIX-системах, SIGSEGV — сигнал, посылаемый процессу при попытке обращения
 * к несуществующей памяти или обращения с нарушением прав доступа.
 *
 * SIGSEGV — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * На самом деле, современные Unix-подобные операционные системы (во всяком
 * случае, на платформе i386) используют для управления памятью технологию
 * страничного преобразования, вызывающую «страничные нарушения» и «нарушения
 * защиты». Сегментация же (и порождаемые ею «нарушения сегментации») не
 * используется, или используется в специфических трюках.
 *
 * Использование:
 * Система отображает память в адресное пространство процесса страницами
 * размером 4—8 КБ (размер страницы зависит от аппаратной платформы, например
 * в i386 это 4 КБ), по мере необходимости — по мере выделения памяти процессом.
 *
 * Также, в адресное пространство могут быть отображены:
 *    файлы — подгрузка соответствующих частей файла (во временных страницах памяти)
 *    при обращении к области пространства, куда он отображён
 *
 *    разделяемая память — страницы памяти, одновременно отображаемые в несколько
 *    процессов другие системные объекты
 *
 * Страницы, в которые ещё ничего не отображено (а также «вытесненные» в
 * процессе свопинга виртуальной памяти, или связанные с ещё незагруженными
 * частями отображённого файла), вызывают страничное нарушение.
 * Обрабатывая страничное нарушение для «вытесненной» страницы памяти или
 * незагруженной части файла, операционная система обеспечивает наличие страницы,
 * вызывавшей нарушение (например, подгружая ее с диска), при возврате к
 * выполнению процесса (и с «вытеснением» другой страницы, если это необходимо).
 * Если же в странице адресного пространства ранее ничего отображено не было,
 * то операционная система посылает процессу сигнал SIGSEGV, чтобы прекратить
 * его выполнение.
 *
 * Кроме этого, каждая страница адресного пространства имеет атрибуты,
 * разрешающие процессу чтение и запись (а новые процессоры также позволяют
 * запретить выполнение программы из памяти страницы, например, для предотвращения
 * выполнения кода при переполнении буфера в стеке).
 * При попытке записи, чтения или выполнения программы в странице, в которой это
 * запрещено, возникает нарушение защиты, обрабатывая которое, операционная
 * система посылает процессу сигнал SIGSEGV, чтобы прекратить его выполнение.
 *
 * Операционная система может предоставить дополнительные данные о возникшей
 * ошибке, используя стек сигнала (англ. signal stack), который может помочь
 * разработчику в отладке данной ошибки.
 *
 * По умолчанию, процесс аварийно завершается с генерацией дампа памяти
 * (и/или другой операции зависящей от платформы), который можно использовать
 * для получения информации об условиях возникновения исключения.
 *
 * SIGSEGV может быть перехвачен или проигнорирован. Однако игнорирование SIGSEGV,
 * в некоторых случаях, может привести к непредсказуемым результатам.
 *
 * Примером программы, перехватывающей SIGSEGV, может служить отладчик, который
 * способен проанализировать стек и информировать разработчика, на каком этапе
 * произошла ошибка.
*/
                                  SIGSEGV,  /* Segmentation violation (ANSI).  */

/* -----------------------------------------------------------------------------
 * См. примечания к SIGUSR1 */
                                  SIGUSR2,  /* User-defined signal 2 (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGPIPE — сигнал, посылаемый процессу при записи в
 * соединение (пайп, сокет) при отсутствии или обрыве соединения с другой
 * (читающей) стороной.
 *
 * SIGPIPE — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * Пайп (англ. pipe) однонаправленный канал между процессами, который позволяет
 * одному процессу пересылать данные другому, без необходимости создавать файлы
 * на диске. Когда пайп рвется, процесс, который пытается туда писать
 * получает SIGPIPE.
 *
 * Наиболее простой вариант пайпа создает шелл Unix, между программами,
 * запускаемыми из командной строки, разделенными символом «|», например,
 * командная строка:
 *   dmesg | less
 * создает пайп от программы dmesg (выводящей отладочные сообщения ядра при
 * загрузке) к программе постраничного просмотра less.
 * Если программа less завершится, прежде чем получит весь вывод dmesg, dmesg
 * будет преждевременно завершена сигналом SIGPIPE.
 *
 * SIGPIPE также может получить программа, работающая с сетевым соединением —
 * сокетом, например, при работе по протоколу TCP из семейства IP.
*/
                                  SIGPIPE,	/* Broken pipe (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGALRM — сигнал, посылаемый процессу по истечении времени
 * предварительно заданном функцией alarm().
 *
 * SIGALRM — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Программы, обычно используют SIGALRM при реализации тайм-аута для
 * долговременной опрерации, или выполнения операции через определённые интервалы.
 *
 * SIGALRM посылается ядром через целое количество секунд после вызова alarm().
 * Иногда этот механизм используется для реализации функции sleep().
*/
                                  SIGALRM,	/* Alarm clock (POSIX).  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGTERM (номер 15) вызывает «вежливое» завершение программы.
 * Получив этот сигнал, программа может выполнить необходимые перед завершением
 * операции (например, высвободить занятые ресурсы).
 * Получение SIGTERM свидетельствует не об ошибке в программе, а о желании ОС
 * или пользователя завершить ее.
 *
 * В POSIX-системах, SIGTERM — сигнал, для запроса завершения процесса.
 *
 * SIGTERM — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGTERM посылается процессу утилитой kill по умолчанию. В отличие от SIGKILL
 * этот сигнал может быть обработан или проигнорирован программой.
 */
                                  SIGTERM,	/* Termination (ANSI).  */

                                  SIGSTKFLT,/* Stack fault.  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGCHLD (номер 17) посылается процессу в том случае, если его дочерний
 * процесс завершился или был приостановлен.
 * Родительский процесс также получит этот сигнал, если он установил режим
 * отслеживания сигналов дочернего процесса и дочерний процесс получил
 * какой-либо сигнал.
 * По умолчанию сигнал SIGCHLD игнорируется.
 *
 * В POSIX-системах SIGCHLD — сигнал, посылаемый при изменении статуса дочернего
 * процесса (завершен, приостановлен или возобновлен).
 *
 * SIGCHLD — целочисленная константа, определенная в заголовочном файле signal.h
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование
 * В Unix процесс может порождать «дочерние» процессы системным вызовом fork()
 * или его вариантами.
 * Родительский процесс, если он существует, уведомляется системой о завершении
 * дочерних процессов (или изменении их состояния) сигналом SIGCHLD.
 * Родительский процесс не должен предпринимать для этого никаких действий.
 * Сигнал может быть игнорирован, если не нуждается в обработке (по умолчанию
 * он игнорируется).
 *
 * Процессы-зомби
 * Основная статья: Процесс-зомби
 * Дочерний процесс по завершении становится «зомби» — пустой записью в таблице
 * процессов, хранящей информацию о завершенном процессе (точнее — код
 * завершения) - до тех пор, пока родительский процесс не получит эту информацию
 * с помощью системного вызова wait() или не завершится сам.
 *
 * В короткоживущих программах наличие «зомби» вполне нормальное явление — зомби
 * не занимают много ресурсов и исчезают с завершением родительского процесса.
 * Но аккуратные программисты всегда заботятся об обработке «зомби». В общем
 * случае для предотвращения накопления «зомби» программа должна использовать
 * обработчик сигнала SIGCHLD c вызовом wait().
 */
                                  SIGCHLD,  /* Same as SIGCHLD (System V).  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGCONT (номер 18) возобновляет выполнение процесса, остановленного
 * сигналом SIGSTOP.
 *
 * В POSIX-системах, SIGCONT — сигнал, посылаемый для возобновления выполнения
 * процесса, ранее остановленного сигналом SIGSTOP или другим сигналом
 * (SIGTSTP, SIGTTIN, SIGTTOU).
 *
 * SIGCONT — целочисленная константа, определенная в заголовочном файле signal.h.
 *
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Сигнал SIGSTOP, посланный процессу приостанавливает его выполнение.
 * Выполнение процесса будет возобновлено только после получения сигнала SIGCONT.
 *
 * Кроме всего прочего, SIGSTOP и SIGCONT используются в механизме управления
 * задачами (англ. job control) шелла Unix.
 */
                                  SIGCONT,  /* Continue (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGSTOP — сигнал, посылаемый для принудительной приостановки
 * выполнения процесса.
 * Для возобновления выполнения используется сигнал SIGCONT.
 *
 * SIGSTOP — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * Сигнал SIGSTOP, посланный процессу приостанавливает его выполнение.
 * Выполнение процесса будет возобновлено только после получения сигнала SIGCONT.
 *
 * Кроме всего прочего, SIGSTOP и SIGCONT используются в механизме управления
 * задачами (англ. job control) шелла Unix.
 *
 * В отличие от сигнала SIGTSTP, SIGSTOP не может быть обработан программой
 * или проигнорирован.
*/
                                  SIGSTOP,  /* Stop, unblockable (POSIX).  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGTSTP (номер 20) приостанавливает процесс по команде пользователя
 * (обычно эта команда – сочетание клавиш Ctrl-Z).
 *
 * В POSIX-системах, SIGTSTP — сигнал, посылаемый c терминала для приостановки
 * выполнения процесса (обычно — комбинацией Ctrl-Z).
 * Для возобновления выполнения используется сигнал SIGCONT.
 *
 * SIGTSTP — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * Сигнал SIGTSTP посылается процессу при нажатии комбинации «стоп» (обычно
 * Ctrl-Z) на управляющем терминале, и, по умолчанию, приостанавливает его
 * выполнение.
 * Выполнение процесса будет возобновлено только после получения сигнала SIGCONT.
 *
 * В отличие от сигнала SIGSTOP, SIGTSTP, может быть обработан программой или
 * проигнорирован.
 */
                                  SIGTSTP,  /* Keyboard stop (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGTTIN — сигнал, посылаемый фоновой задаче при попытке
 * чтения с управляющего терминала.
 *
 * SIGTTIN — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGTTIN может быть послан фоновому процессу при попытке чтения с управляющего
 * терминала. Обычно этот сигнал применяется в управлении задачами шелла Unix.
 * Демоны Unix не имеют управляющих терминалов (демон закрывает файловые
 * дескприпторы stdin, stdout, stderr при запуске).
 *
 * При получении сигнала задача приостанавливается до получения SIGCONT,
 * посылаемого при переводе программы с фона на передний план командой fg или
 * пользователем (с помощью утилиты kill).
*/
                                  SIGTTIN,  /* Background read from tty (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGTTOU — сигнал посылаемый фоновой задаче, при попытке
 * вывода на управляющий терминал.
 *
 * SIGTTOU — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGTTOU может быть послан фоновому процессу, при попытке вывода на управляющий
 * терминал. Обычно этот сигнал применяется в управлении задачами шелла Unix.
 * Демоны Unix не имеют управляющих терминалов (демон закрывает файловые
 * дескприпторы stdin, stdout, stderr при запуске).
 *
 * При получении сигнала, задача приостанавливается до получения SIGCONT,
 * посылаемого при переводе программы с фона на передний план командой fg.
*/
                                  SIGTTOU,  /* Background write to tty (POSIX).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGURG — сигнал, посылаемый процессу при появлении на сокете
 * доступных для чтения срочных (англ. urgent) данных.
 *
 * SIGURG — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGURG посылается при получении данных по срочному каналу (англ. out-of-band
 * data) на сокет с разрешенным асинхронным вводом-выводом (флагом F_SETOWN
 * системного вызова fcntl Linux и BSD).
 * Сами данные можно считать с помощью системного вызова recv.
*/
                                  SIGURG,   /* Urgent condition on socket (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGXCPU — сигнал, посылаемый компьютерной программе,
 * превышающей лимит процессорного времени.
 *
 * SIGXCPU — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGXCPU посылается, когда время, потраченное процессором для выполнения
 * процесса, превышает допустимое значение (определенное системным вызовом
 * fcntl и шеллом).
 *
 * Процессорное время, это не время, прошедшее с запуска процесса, а только то
 * время, в течение которого процессор занимался его выполнением (в остальное
 * время процесс ожидает ввода-вывода и обслуживание системой других процессов).
 *
 * На некоторых операционных системах, Boehm garbage collector использует
 * SIGXCPU и SIGPWR для синхронизации кросс-процессного сбора мусора.
*/
                                  SIGXCPU,  /* CPU limit exceeded (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGXFSZ — сигнал, посылаемый процессу при превышении
 * открытым файлом максимально допустимого размера.
 *
 * SIGXFSZ — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * Посылка данного сигнала определяется реализацией системного вызова ulimit() и
 * шелла Unix.
*/
                                  SIGXFSZ,  /* File size limit exceeded (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGVTALRM — сигнал, посылаемый процессу по истечении
 * времени заданном в «виртуальном» таймере.
 *
 * SIGVTALRM — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGVTALRM посылается процессу по истечении таймера, точно так же как SIGALRM
 * и SIGPROF. В отличие от SIGALRM, измеряющего реальное время, SIGVTALRM
 * измеряет только время выполнения процесса. SIGPROFF также измеряет время
 * выполнения процесса, а также время ожидания процессом завершения системных
 * вызовов.
 *
 * SIGVTALRM и SIGPROF используются при профилировании, для сбора статистики о
 * времени выполнении процесса и ожидании системных вызовов (выполнения в
 * пространстве ядра).
*/
                                  SIGVTALRM,/* Virtual alarm clock (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGPROF — сигнал, посылаемый процессу по истечении времени
 * заданном в таймере профилирования.
 *
 * SIGPROF — целочисленная константа, определённая в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * SIGPROF посылается по истечении таймера, как SIGVTALRM или, более популярный
 * SIGALRM. Их отличие в том, что SIGPROF, измеряет время выполнения самого
 * процесса и время, проведённое в ожидании завершения системных вызовов,
 * SIGVTALRM измеряет только время выполнения самого процесса, а SIGALRM
 * измеряет реальное время.
 *
 * При профилировании, для сбора статистики о времени выполнении процесса и
 * ожидании системных вызовов (выполнения в пространстве ядра) используются
 * SIGPROF и SIGVTALRM.
*/
                                  SIGPROF,  /* Profiling alarm clock (4.2 BSD).  */

                                  SIGWINCH, /* Window size change (4.3 BSD, Sun).  */

/* -----------------------------------------------------------------------------
 * Сигнал SIGIO/SIGPOLL (в Linux обе константы обозначают один сигнал – номер 29)
 * сообщает процессу, что на одном из дескрипторов, открытых асинхронно,
 * появились данные.
 * По умолчанию этот сигнал, как ни странно, завершает работу программы.
 *
 * В POSIX-системах SIGPOLL — сигнал, посылаемый процессу для информирования об
 * изменении состояния выполняющегося в фоне асинхронного ввода-вывода.
 *
 * SIGPOLL — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Сигнал SIGIO в Linux является синонимом SIGPOLL.
 *
 * Использование:
 * Согласно POSIX, SIGPOLL — сигнал по умолчанию, посылаемый при изменении
 * состояния открытого файла (например, готовности к вводу или выводу), для
 * которого системным вызовом ioctl был установлен флаг I_SETSIG.
 *
 * Используя этот механизм, программа может осуществлять асинхронный ввод-вывод
 * без необходимости дополнительного мультиплексирования, которое необходимо при
 * использовании функции select(). Возможным минусом данного метода является
 * потеря непрерывности в коде программы и превращения его в нечитабельное
 * «спагетти», с потенциальной возможностью возникновения ошибок
 * типа race condition.
 *
 * POSIX 1003.1 (2003 год) рекомендует использование стандартизированных
 * системных вызовов для асинхронного ввода-вывода, определяемых заголовочным
 * файлом aio.h. Всем запросы на ввод-вывод с использованием этих функций
 * ставятся в очередь для асинхронного выполнения, их результаты и состояние
 * могут быть получены через функции aio_return() и aio_error().
 */
                                  SIGIO,    /* I/O now possible (4.2 BSD).  */

/* -----------------------------------------------------------------------------
 */
                                  SIGPWR,   /* Power failure restart (System V).  */

/* -----------------------------------------------------------------------------
 * В POSIX-системах, SIGSYS — сигнал, предназначенный для посылки программе,
 * при попытке передать неправильный аргумент в системный вызов.
 *
 * SIGSYS — целочисленная константа, определенная в заголовочном файле signal.h.
 * Символьные имена сигналов используются вместо номеров, так как в разных
 * реализациях номера сигналов могут различаться.
 *
 * Использование:
 * Теоретически, SIGSYS может быть послан, когда процесс передает неправильный
 * аргумент в системный вызов. На практике же, система возвращает ENOSYS, если
 * системного вызова с запрошенным кодом не существует или соответствующую
 * ошибку, если аргумент системного вызова неправилен (например, EBADF, если
 * заданного файлового дескриптора не существует). POSIX.1 говорит о SIGSYS
 * следующим образом:
 *    There is very little that a conforming POSIX.1 application can do by catching,
 *    ignoring or masking ...
 *
 *    SIGSYS. ...
 *    One portable use that does exist ... is that a command interpreter can
 *    recognize them as the cause of a process's termination.
 *
 * Приложение, отвечающее POSIX.1 при перехвате SIGSYS, мало что может сделать
 * с ним. Например, командный интерпретатор может указать его как причину
 * завершения процесса.
*/
                                  SIGSYS,   /* Bad system call.  */
};

//------------------------------------------------------------------------------
bool SignalValid ( const std::sig_atomic_t sN );

using signal_action_t   = std::function< void(int) >;

/**
 * @brief handler
 * @param s
 */
void handler( int s );

/**
 * @brief The signal_info struct
 */
struct signal_info
{
  struct sigaction  m_sa;

  signal_info();
  signal_info( std::sig_atomic_t sn, signal_action_t sh );

  bool set_signal( std::sig_atomic_t sn, signal_action_t sh );
  bool set_signal_ignore( std::sig_atomic_t sn );
  bool set_signal_default( std::sig_atomic_t sn );
};

/**
 * @typedef signals_map_t
 * @brief Ассоциативный контейнер-карта пар соответствий номера сигнала и его обработчика.
 *
 * @see signals_t, signals_fnc_t
 */
using signals_map_t             = std::map< std::sig_atomic_t, signal_action_t >;

//------------------------------------------------------------------------------
/**
 * @brief Класс SysSignalsController реализует данные и методы для работы с
 *        сигналами ОC *NIX.
 */
class COMMON_SHARED_EXPORT        SysSignalsController
{
  friend class handler;
public:
  /**
   * @brief Конструктор SysSignalsController экземпляра класа.
   * Инициализирует аргумент @a m_Signal в значение , равное -1, что сообщает об
   * отсутствии обрабатываемого сигнала.
   *
   */
  /**/                            SysSignalsController  ();
  /**
   * @brief Деструктор ~SysSignalsController экземпляра класса.
   */
  virtual                       ~ SysSignalsController  ();

  /**
   * @brief Метод AddIgnore добавляет значение сигнала типа @a signals_t::value_type
   * в контейнер сигналов с игнорированием обработки.
   * @return После успешного добавления возвращает значение сигнала или -1,
   * усли добавление невозможно.
   * @see signals_t, SysSignalsController::AddToContainer
   */
  virtual bool                    AddIgnore             ( std::sig_atomic_t );
  /**
   * @brief Метод AddDefault добавляет значение сигнала типа @a signals_t::value_type
   * в контейнер сигналов с обработчиком, заданным ОС *NIX по умолчанию.
   * @return После успешного добавления возвращает значение сигнала или -1,
   * усли добавление невозможно.
   * @see signals_t, SysSignalsController::AddToContainer
   */
  virtual bool                    AddDefault            ( std::sig_atomic_t );
  /**
   * @brief Метод AddAction добавляет значение сигнала типа @a signals_t::value_type
   *        и его обработчик типа @a signals_fnc_t в контейнер сигналов с обработчиком.
   * @return После успешного добавления возвращает значение сигнала или -1,
   *          если добавление невозможно.
   * @see signals_t, signals_fnc_t, SysSignalsController::m_ActionsMap
   */
  virtual bool                    AddAction             ( std::sig_atomic_t, signal_action_t );

  /**
   * @brief Метод SendSignal отправляет сигнал типа @a signals_t::value_type на
   *        обработку в ОС *NIX.
   * @return После успешной отправки возвращает значение сигнала или -1,
   *        если отправка невозможна.
   * @see std::raise, signals_t
   */
  virtual signals_t::value_type   SendSignal            ( signals_t::value_type );

protected:
  mutable std::recursive_mutex    m_Mutex;
};

//------------------------------------------------------------------------------

}// namespace                     sys
}// namespace                     ред

#endif // SYSSIGNALSCONTROLLER_H
